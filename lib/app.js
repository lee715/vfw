// Generated by CoffeeScript 1.9.1
(function() {
  var Extend, Parser, Rule, RuleSet, V, _;

  Extend = require('./extend');

  Parser = require('./parser');

  RuleSet = require('./classes/ruleset');

  Rule = require('./classes/rule');

  require('./internal/ruletype');

  _ = require('lodash');

  V = module.exports = {};

  Object.keys(Extend.map).forEach(function(name) {
    return V[name] = function() {
      var handler;
      handler = Extend.map[name];
      return handler.check.apply(handler, arguments);
    };
  });

  V.check = function() {};

  V.get = function(rule) {
    return V.Extend.get(rule);
  };

  V.Extend = Extend;

  V.extendParser = function(fn) {
    return Parser.add(fn);
  };

  V.extend = function(type) {
    var args, ruleType;
    ruleType = Extend.getByName(type);
    args = [].slice.call(arguments, 1);
    return ruleType.extend.apply(ruleType, args);
  };

  V.include = function(type) {
    var args, ruleType;
    ruleType = Extend.getByName(type);
    args = [].slice.call(arguments, 1);
    if (ruleType.include) {
      return ruleType.include.apply(ruleType, args);
    }
  };

  V.parse = function(obj) {
    var _parse, depth, ruleSet;
    if (!obj) {
      return null;
    }
    depth = 0;
    ruleSet = new RuleSet();
    _parse = function(data, ruleIns) {
      var handler, i, keys, len, parsed, parser, parsers;
      depth++;
      handler = Extend.get(data);
      if (handler) {
        ruleIns.setHandler(handler, data);
        return ruleSet.add(ruleIns);
      }
      parsers = Parser.get();
      for (i = 0, len = parsers.length; i < len; i++) {
        parser = parsers[i];
        parsed = parser(data, ruleSet, ruleIns);
        if (parsed) {
          return;
        }
      }
      if (_.isArray(data)) {
        return data.forEach(function(item, ind) {
          var _ruleIns;
          _ruleIns = ruleIns.clone(ind);
          _ruleIns.addPath(ind, depth);
          return _parse(item, _ruleIns);
        });
      } else if (_.isPlainObject(data)) {
        keys = Object.keys(data);
        if (keys.length === 1) {
          return keys.forEach(function(key, ind) {
            var _ruleIns;
            _ruleIns = ruleIns.clone(ind);
            _ruleIns.addPath(key, depth);
            return _parse(data[key], _ruleIns);
          });
        } else {
          return keys.forEach(function(key, ind) {
            var _rule, _ruleIns;
            _ruleIns = ruleIns.clone(ind);
            _rule = {};
            _rule[key] = data[key];
            return _parse(_rule, _ruleIns);
          });
        }
      } else {
        throw new Error("unrecognized rule: " + data);
      }
    };
    _parse(obj, new Rule());
    return ruleSet;
  };

}).call(this);
