// Generated by CoffeeScript 1.9.1
(function() {
  var CUKEY, CUS, Extends, MEKEY, OPKEY, OPS, OPTS, SYS, _, afterSYS, check, checkAll, extend, formatSysKey, getMethod, isArray, isCustomHandlerKey, isEmpty, isFunction, isObject, isOpArgs, isString, isSysKey, isUndefined, parse, result, validator,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  validator = require('validator');

  _ = require('lodash');

  isString = _.isString, isArray = _.isArray, isObject = _.isObject, isUndefined = _.isUndefined, isFunction = _.isFunction;

  OPS = '$in,$eq,$neq'.split(',');

  SYS = '$or,$and'.split(',');

  CUS = '$required,$empty'.split(',');

  OPKEY = 'op';

  CUKEY = 'cu';

  MEKEY = 'me';

  Extends = {};

  OPTS = {
    format: false
  };

  Extends[OPKEY] = {
    $in: function(target, arr) {
      return indexOf.call(arr, target) >= 0;
    },
    $eq: _.isEqual,
    $neq: function() {
      return !_.isEqual.apply(_, arguments);
    }
  };

  Extends[CUKEY] = {
    $required: function(target, required) {
      if (required && isUndefined(target)) {
        return false;
      } else if (!required && isUndefined(target)) {
        return 'passed';
      } else {
        return true;
      }
    },
    $empty: function(target, empty) {
      if (!empty && isEmpty(target)) {
        return false;
      } else if (empty && isEmpty(target)) {
        return 'passed';
      } else {
        return true;
      }
    }
  };

  Extends[MEKEY] = {
    $type: function(target, type) {
      return getMethod(type)(target);
    }
  };

  extend = function(type) {
    var _extend;
    _extend = function(handler, name) {
      if (type !== MEKEY && !/^\$/.test(name)) {
        return false;
      }
      if (Extends[type][name]) {
        console.warn("key " + name + " is already existed");
      }
      Extends[type][name] = handler;
      if (type === OPKEY) {
        OPS.push(name);
      } else if (type === CUKEY) {
        CUS.push(name);
      }
      return name;
    };
    return function(name, handler) {
      if (isObject(name)) {
        return _.mapKeys(name, _extend);
      } else {
        return _extend(handler, name);
      }
    };
  };

  isEmpty = function(obj) {
    if (isArray(obj) && obj.length === 0) {
      return true;
    }
    if (isObject(obj) && _.keys(obj).length === 0) {
      return true;
    }
    if (obj === '') {
      return true;
    }
    return false;
  };

  afterSYS = function(path) {
    return isSysKey(_.last(path));
  };

  isSysKey = function(key) {
    return /^\$(and|or)/.test(key);
  };

  isOpArgs = function(obj) {
    if (obj && obj.$query && obj.$addtions) {
      return true;
    } else {
      return false;
    }
  };

  isCustomHandlerKey = function(key) {
    return /^\$FN/.test(key);
  };

  formatSysKey = function(key) {
    if (/^\$or/.test(key)) {
      return 'or';
    } else {
      return 'and';
    }
  };

  getMethod = function(name) {
    var extendFn;
    extendFn = Extends[MEKEY][name];
    if (extendFn) {
      return extendFn;
    } else {
      return validator[name];
    }
  };

  result = function(obj, path) {
    var curriedResult, max, pis, rt;
    if (!(obj && path)) {
      return obj;
    }
    if (~path.indexOf('$array')) {
      pis = path.split(/^\$array\.|\.\$array\.|\.\$array$/);
      rt = obj;
      curriedResult = _.curryRight(_.result)(void 0);
      max = pis.length - 1;
      pis.forEach(function(p, ind) {
        if (p === '' && ind === max) {
          return rt = [].concat.apply([], rt);
        } else {
          if (isArray(rt)) {
            rt = _.map(rt, function(r) {
              return curriedResult(p)(r);
            });
            if (ind < max) {
              return rt = [].concat.apply([], rt);
            }
          } else if (isObject(rt)) {
            return rt = _.result(rt, p);
          }
        }
      });
      return rt;
    } else {
      return _.result(obj, path);
    }
  };

  parse = function(obj) {
    var _format, _parse, _toRule, andCount, data, getKey, orCount, rt, rules;
    if (isObject(obj)) {
      data = obj;
    } else if (isArray(obj)) {
      return obj.map(function(d) {
        return parse(d);
      });
    } else {
      return null;
    }
    orCount = 1;
    andCount = 1;
    getKey = function(type) {
      if (type === 'or') {
        return "$or" + (orCount++);
      } else {
        return "$and" + (andCount++);
      }
    };
    rt = [];
    _parse = function(data, path) {
      var andKey, keys, orKey;
      andKey = getKey('and');
      orKey = getKey('or');
      if (isObject(data)) {
        keys = Object.keys(data);
        return keys.forEach(function(key) {
          if (indexOf.call(OPS, key) >= 0) {
            return _toRule(data, path, key);
          } else if (indexOf.call(CUS, key) >= 0) {
            return _parse(data[key], path.concat(key));
          } else if (isSysKey(key)) {
            return _parse(data[key], path.concat(key === '$and' ? andKey : getKey('or')));
          } else {
            if (!afterSYS(path)) {
              path.push(andKey);
            }
            return _parse(data[key], path.concat(key));
          }
        });
      } else if (isArray(data)) {
        return data.forEach(function(item, ind) {
          return _parse(item, path.concat(!afterSYS(path) ? [andKey, ind] : ind));
        });
      } else if (isString(data)) {
        return _toRule(data, path, _.last(path));
      } else if (isFunction(data)) {
        return _toRule(data, path, _.last(path));
      } else {
        return console.log('err', path);
      }
    };
    _toRule = function(data, path, key) {
      var addtions, ps, rule, type;
      rule = {};
      if (indexOf.call(OPS, key) >= 0) {
        rule.path = path;
        rule.check = [key, data[key]];
      } else if (isString(data)) {
        rule.path = path;
        ps = data.split(':');
        type = ps[0];
        addtions = ps.slice(1);
        rule.check = ['$type', type];
        addtions.forEach(function(addtion) {
          return rule["$" + addtion] = true;
        });
      } else if (isFunction(data)) {
        rule.path = path;
        rule.check = ["$FN:" + key, data];
      } else {
        return;
      }
      return rt.push(rule);
    };
    _format = function(rules) {
      rt = [];
      rules.forEach(function(rule) {
        var check, key, keys, path, sys;
        path = rule.path, check = rule.check;
        CUS.forEach(function(ckey) {
          if (indexOf.call(path, ckey) >= 0) {
            path = _.without(path, ckey);
            return rule[ckey] = true;
          }
        });
        keys = [];
        sys = [];
        path.forEach(function(p) {
          return (isSysKey(p) ? sys : keys).push(p);
        });
        key = keys.pop();
        if (key === '$array') {
          key = keys.pop();
          rule.isArray = true;
        }
        rule.key = key;
        rule.path = keys.join('.');
        rule.sys = sys;
        rule.id = _.uniqueId('rule_');
        return rt.push(rule);
      });
      return rt;
    };
    _parse(data, ['$and0']);
    rules = _format(rt);
    return rules;
  };

  checkAll = function(obj, rules) {
    var _resolve, errArr, errObj, maxLen, queue, rt, rulesById, trackErr;
    rt = null;
    queue = [];
    maxLen = 0;
    rulesById = {};
    errArr = null;
    errObj = {};
    trackErr = function(op, res, items) {
      var val;
      val = res ? 0 : 1;
      return items.forEach(function(arg) {
        var id, ids, rt, sys;
        sys = arg[0], rt = arg[1], id = arg[2];
        if (_.isArray(id)) {
          ids = _.flatten(id, true);
          return ids.forEach(function(id) {
            return errObj[id] = val;
          });
        } else {
          return errObj[id] = val;
        }
      });
    };
    _resolve = function(table, maxLen) {
      var rest, toResolve;
      if (maxLen) {
        toResolve = {};
        rest = table.filter(function(arg) {
          var id, key, res, sop, sys;
          sys = arg[0], res = arg[1], id = arg[2];
          if (sys.length === maxLen) {
            key = sys.join('.');
            sop = sys.pop();
            (toResolve[key] || (toResolve[key] = [sop])).push([sop, res, id]);
            return false;
          } else {
            return true;
          }
        });
        _.mapKeys(toResolve, function(val, key) {
          var ids, items, op, rts, symbol;
          op = formatSysKey(val[0]);
          items = val.slice(1);
          rts = _.pluck(items, '1');
          ids = _.pluck(items, '2');
          if (op === 'or') {
            symbol = '||';
          } else {
            symbol = '&&';
          }
          rt = eval(rts.join(symbol));
          trackErr(op, rt, items);
          return rest.push([key.split('.').slice(0, -1), rt, ids]);
        });
        maxLen--;
        return _resolve(rest, maxLen);
      } else {
        rt = eval((table.map(function(arr) {
          return arr[1];
        })).join('&&'));
        trackErr('and', rt, table);
        return rt;
      }
    };
    rules.forEach(function(rule) {
      var err, len, ref, res, target;
      ref = check(obj, rule), err = ref[0], res = ref[1], target = ref[2];
      queue.push([rule.sys.slice(), res, rule.id]);
      rulesById[rule.id] = {
        path: rule.path,
        err: err,
        target: target,
        key: rule.key
      };
      len = rule.sys.length;
      if (len > maxLen) {
        return maxLen = len;
      }
    });
    rt = _resolve(queue, maxLen);
    _.mapKeys(errObj, function(value, key) {
      if (value && rulesById[key].err) {
        errArr || (errArr = []);
        return errArr.push(rulesById[key]);
      }
    });
    return [errArr, rt];
  };

  check = function(obj, rule) {
    var _check, _wrap, data, err, i, key, len1, method, op, path, ref, rt, tar, target;
    path = rule.path, key = rule.key;
    ref = rule.check, op = ref[0], data = ref[1];
    target = result(obj, path);
    rt = false;
    err = null;
    if (isCustomHandlerKey(op)) {
      method = data;
    } else if (indexOf.call(OPS, op) >= 0) {
      method = Extends[OPKEY][op];
    } else {
      method = getMethod(data);
    }
    _wrap = function(target, handler, addtion) {
      var rest, results, single, wrapRt;
      single = false;
      if (!rule.isArray) {
        target = [target];
        single = true;
      }
      if (rule.isArray && isUndefined(target)) {
        target = [target];
        single = true;
      }
      if (rule.isArray && isEmpty(target)) {
        target = [''];
      }
      rest = [];
      results = _.map(target, function(tar) {
        var r;
        r = handler(tar, addtion);
        if (r !== 'passed') {
          rest.push(tar);
        }
        return r;
      });
      wrapRt = _.reduce(results, function(a, b) {
        return a && b;
      });
      results = single ? results[0] : results;
      rest = single ? rest[0] : rest;
      return [wrapRt, results, rest];
    };
    _check = function(tar, key) {
      var cusRule, handler, i, len1, ref1, ref2, rest, rts, toCheck;
      toCheck = tar && tar[key];
      for (i = 0, len1 = CUS.length; i < len1; i++) {
        cusRule = CUS[i];
        handler = Extends[CUKEY][cusRule];
        ref1 = _wrap(toCheck, handler, rule[cusRule]), rt = ref1[0], rts = ref1[1], rest = ref1[2];
        if (!rt) {
          err = cusRule;
          return false;
        }
        if (isUndefined(rest) || (isArray(rest) && !rest.length)) {
          return true;
        }
        toCheck = rest;
      }
      if (!method) {
        rt = false;
        err = 'Operation';
      } else {
        ref2 = _wrap(toCheck, method, data), rt = ref2[0], rts = ref2[1];
        if (OPTS.format) {
          tar[key] = rts;
        }
        if (!rt) {
          err = [op, data];
        }
      }
      return rt;
    };
    if (isArray(target) && /\$array$/.test(path)) {
      for (i = 0, len1 = target.length; i < len1; i++) {
        tar = target[i];
        rt = _check(tar, key);
        if (err) {
          break;
        }
      }
      if (!err) {
        rt = true;
      }
    } else {
      rt = _check(target, key);
    }
    return [err, !!rt, target[key]];
  };

  module.exports = {
    extendOperation: extend(OPKEY),
    extendAddtion: extend(CUKEY),
    extendMethod: extend(MEKEY),
    checkAll: checkAll,
    parse: parse,
    checkRule: function(data, rule) {
      rule = parse(rule);
      return checkAll(data, rule);
    },
    config: function(opts) {
      return OPTS = _.assign(OPTS, opts);
    },
    type: function(type, target) {
      return Extends[MEKEY].$type(target, type);
    }
  };

  _.assign(module.exports, Extends[OPKEY]);

  _.assign(module.exports, Extends[CUKEY]);

}).call(this);
