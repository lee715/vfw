// Generated by CoffeeScript 1.10.0
(function() {
  var Extend, Rule, RuleSet, Tree, _, afterLogic, parsers, u;

  _ = require('lodash');

  u = require('../util');

  Extend = require('../extend');

  Tree = require('./tree');

  Rule = require('./rule');

  parsers = require('../parser').get();

  afterLogic = function(path) {
    if (path.length === 0) {
      return false;
    }
    return Extend.getByName('logic').has(_.last(path));
  };

  RuleSet = (function() {
    function RuleSet(obj) {
      this.uid = _.uniqueId('RuleSet_');
      this._treeHdl = new Tree;
      this._rules = [];
      this._ruleMap = {};
      this.parse(obj);
      this;
    }

    RuleSet.prototype.uniqRule = function() {
      return _.uniqueId(this.uid + '_');
    };

    RuleSet.prototype._add = function(ruleIns) {
      var _addition, _logicChain, _path, _rule;
      _path = ruleIns._path, _rule = ruleIns._rule, _logicChain = ruleIns._logicChain, _addition = ruleIns._addition;
      ruleIns.uid = this.uniqRule();
      this._rules.push(ruleIns);
      this._ruleMap[ruleIns.uid] = ruleIns;
      this._treeHdl.initByChain(_logicChain, ruleIns.uid);
      return this;
    };

    RuleSet.prototype.check = function(obj) {
      var errs, res, rules, uids, valObj;
      rules = this._rules;
      valObj = {};
      rules.forEach(function(rule) {
        var rt;
        rt = rule.check(obj);
        return valObj[rule.uid] = rt;
      });
      res = !!this._treeHdl.resolve(valObj);
      if (!res) {
        uids = this._treeHdl.findErrorLeafs();
      }
      errs = _.map(uids, (function(_this) {
        return function(uid) {
          return _this._ruleMap[uid].toJSON();
        };
      })(this));
      return [res, errs];
    };

    RuleSet.prototype.add = function(ruleIns) {
      return this._add(ruleIns.finish());
    };

    RuleSet.prototype.parse = function(obj) {
      var _parse, depth, ruleSet;
      if (!obj) {
        return null;
      }
      depth = 0;
      ruleSet = this;
      _parse = function(data, ruleIns) {
        var handler, i, keys, len, parsed, parser;
        depth++;
        if (_.isArray(data)) {
          return data.forEach(function(item, ind) {
            var _ruleIns;
            _ruleIns = ruleIns.clone(ind);
            _ruleIns.addPath(ind, depth);
            return _parse(item, _ruleIns);
          });
        } else {
          handler = ruleSet._q.getHandler(data, 'check');
          if (handler) {
            ruleIns.addHandler(handler);
            return ruleSet.end(ruleIns);
          } else if (_.isPlainObject(data)) {
            keys = Object.keys(data);
            if (ruleSet._q.isRuleWithPrecheck(keys)) {
              keys.forEach(function(key) {
                var stage;
                handler = ruleSet._q.getHandlerByKey(key);
                stage = handler.getStage();
                if (stage === 'check') {
                  return ruleIns.addHandler(handler);
                } else {
                  return ruleIns.addRuleByStage(key, data[key], stage);
                }
              });
              return ruleSet.end(ruleIns);
            } else {
              return keys.forEach(function(key, ind) {
                var _ruleIns;
                _ruleIns = ruleIns.clone(ind);
                _ruleIns.addPath(key, depth);
                return _parse(data[key], _ruleIns);
              });
            }
          } else {
            for (i = 0, len = parsers.length; i < len; i++) {
              parser = parsers[i];
              parsed = parser(data, ruleSet, ruleIns);
              if (parsed) {
                return;
              }
            }
            throw new Error('unrecognized rule');
          }
        }
      };
      return _parse(obj, new Rule());
    };

    return RuleSet;

  })();

  module.exports = RuleSet;

}).call(this);
