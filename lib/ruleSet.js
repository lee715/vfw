// Generated by CoffeeScript 1.9.1
(function() {
  var Extends, Rule, RuleSet, Tree, _, afterLogic, u;

  _ = require('lodash');

  u = require('./util');

  Extends = require('./extends');

  Tree = require('./tree');

  Rule = require('./rule');

  afterLogic = function(path) {
    if (path.length === 0) {
      return false;
    }
    return Extends.logic.has(_.last(path));
  };

  RuleSet = (function() {
    function RuleSet(obj) {
      this.uid = _.uniqueId('RuleSet_');
      this._treeHdl = new Tree;
      this._rules = [];
      this._ruleMap = {};
      this.parse(obj);
      this;
    }

    RuleSet.prototype.uniqRule = function() {
      return _.uniqueId(this.uid + '_');
    };

    RuleSet.prototype.add = function(rule) {
      var addition, check, logicChain, path, ruleHdl;
      path = rule.path, check = rule.check, logicChain = rule.logicChain, addition = rule.addition;
      ruleHdl = new Rule(check, addition, path);
      ruleHdl.uid = this.uniqRule();
      this._rules.push(ruleHdl);
      this._ruleMap[ruleHdl.uid] = ruleHdl;
      this._treeHdl.initByChain(logicChain, ruleHdl.uid);
      return this;
    };

    RuleSet.prototype.check = function(obj) {
      var errs, res, rules, uids, valObj;
      rules = this._rules;
      valObj = {};
      rules.forEach(function(rule) {
        var rt;
        rt = rule.check(obj);
        return valObj[rule.uid] = rt;
      });
      res = !!this._treeHdl.resolve(valObj);
      uids;
      if (!res) {
        uids = this._treeHdl.findErrorLeafs();
      }
      errs = _.map(uids, (function(_this) {
        return function(uid) {
          return _this._ruleMap[uid].toJSON();
        };
      })(this));
      return [res, errs];
    };

    RuleSet.prototype.parse = function(obj) {
      var _format, _parse, _toRule, depth, getKey, ruleSet;
      if (!obj) {
        return null;
      }
      depth = 0;
      getKey = function(sysKey) {
        return "" + sysKey + depth;
      };
      ruleSet = this;
      _parse = function(data, path) {
        var andKey, keys;
        depth++;
        andKey = getKey('$and');
        if (_.isArray(data)) {
          return data.forEach(function(item, ind) {
            return _parse(item, path.concat(!afterLogic(path) ? [andKey, ind] : ind));
          });
        } else if (_.isFunction(data)) {
          return _toRule(data, path, _.last(path));
        } else if (_.isPlainObject(data)) {
          keys = Object.keys(data);
          return keys.forEach(function(key) {
            if (Extends.operation.has(key)) {
              return _toRule(data, path, key);
            } else if (Extends.addition.has(key)) {
              return _parse(data[key], path.concat(key));
            } else if (Extends.logic.has(key)) {
              return _parse(data[key], path.concat(getKey(key)));
            } else {
              if (!afterLogic(path)) {
                path.push(andKey);
              }
              return _parse(data[key], path.concat(key));
            }
          });
        } else if (_.isString(data)) {
          return _toRule(data, path, _.last(path));
        } else {
          return console.log('err', path);
        }
      };
      _toRule = function(data, path, key) {
        var additions, formated, ps, rule, type;
        rule = {};
        if (Extends.operation.has(key)) {
          rule.path = path;
          rule.check = data;
        } else if (_.isString(data)) {
          rule.path = path;
          ps = data.split(':');
          type = ps[0];
          additions = ps.slice(1);
          rule.check = type;
          rule.addition = {};
          additions.forEach(function(addition) {
            return rule.addition["$" + addition] = true;
          });
        } else if (_.isFunction(data)) {
          rule.path = path;
          rule.check = data;
        } else {
          return;
        }
        formated = _format(rule);
        if (formated) {
          return ruleSet.add(formated);
        }
      };
      _format = function(rule) {
        var check, keys, last, logics, path;
        path = rule.path, check = rule.check;
        keys = [];
        logics = [];
        last = null;
        path.forEach(function(p) {
          if (Extends.addition.has(p)) {
            return rule.addition[p] = true;
          }
          if (Extends.logic.has(p)) {
            return logics.push(p);
          } else if (p === '$array' && last === p) {

          } else {
            last = p;
            return keys.push(p);
          }
        });
        rule.path = keys.join('.');
        rule.logicChain = logics;
        return rule;
      };
      return _parse(obj, []);
    };

    return RuleSet;

  })();

  module.exports = RuleSet;

}).call(this);
